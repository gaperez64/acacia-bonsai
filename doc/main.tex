\documentclass[runningheads,a4paper,draft]{llncs}

\usepackage{amssymb,amstext,amsmath}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage{cleveref}
\usepackage[basic,bold]{complexity}

% Usual math notation fixes
\makeatletter
\let\epsilon\varepsilon
\let\phi\varphi
\let\emptyset\varnothing
\makeatother

% Todonotes
\usepackage{todonotes,setspace,marginnote,xstring}
\newcounter{authornotes}
\newcommand\authornote[3][]{%
  \refstepcounter{authornotes}%
  {%
    \IfSubStr{,#1,}{,inline,}{}{\setstretch{0.7}}%
    \todo[size=\small,#1]{%
      \textbf{\uppercase{#2}\theauthornotes:}~#3}%
  }}
\newcommand\gpnote[2][]{\authornote[color={red!100!green!33},#1]{GP}{#2}}
\newcommand\mcnote[2][]{\authornote[color={blue!50!green!20},#1]{MC}{#2}}
\def\mathnote#1{{\let\marginpar\marginnote\textrm{\normalfont #1}}}

% Local macros
\newcommand{\indicator}[2]{\mathbf{1}_{#1}(#2)}
\newcommand{\pow}[1]{\mathcal{P}(#1)}
\newcommand{\cpre}{\mathbf{CPre}}
\newcommand{\eve}{Eve\xspace}
\newcommand{\adam}{Adam\xspace}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\frakA}{\mathfrak{A}}
\renewcommand{\lang}[1]{\mathcal{L}({#1})}
\newcommand{\out}[2]{\pi_{#1#2}}
\newcommand{\closedn}[1]{\mathrm{\downarrow} #1}
\newcommand{\pseudopre}{\widehat{\mathrm{Pre}}}

% Watermark
\usepackage{ifdraft}
\ifdraft{
  \usepackage{draftwatermark}
  \SetWatermarkAngle{0}
  \SetWatermarkLightness{0.7}
  \SetWatermarkFontSize{0.7cm}
  % \SetWatermarkHorCenter
  \SetWatermarkVerCenter{1cm}
  \usepackage{datetime2}
  %\DTMsetstyle{ddmmyy}
  \SetWatermarkText{{DRAFT  (comp. on: \DTMtoday, \DTMcurrenttime)}}
}

\begin{document}



\title{Acacia Bonsai: A Minimal Implementation of Antichain-Based Algorithms
for LTL Synthesis}
\titlerunning{Acacia Bonsai: LTL Synthesis with Antichains}

\author{Micha\"el Cadilhac\inst{1} \and
Guillermo A. P\'erez\inst{2}} %\orcidID{0000-0002-1200-4952}}
\institute{DePaul University, U.S.A.\\
\email{michael@cadilhac.name} \and
University of Antwerp, Belgium\\
\email{guillermoalberto.perez@uantwerpen.be}
}
\authorrunning{M. Cadilhac \and G. A. P\'erez}

\maketitle

\begin{abstract}
  We describe our re-implementation of antichain-based algorithms used to
  solve the reactive synthesis problem with linear temporal logic (LTL)
  specifications. Formally, we study Gale-Stewart games played between an
  input and an output player (called \adam and \eve, respectively) and with
  payoff set being the complement of the language of a given B\"uchi
  automaton: if the infinite input-output sequence is accepted by the
  automaton, then \adam wins, otherwise \eve wins. To efficiently compute a
  winning strategy for one of the players, we use antichains as a symbolic
  representation of closed sets of configurations of the game.
  \keywords{Reactive synthesis \and LTL \and Antichains \and Data structures}
\end{abstract}

\section{Definitions}
An \emph{infinite word} $\alpha$ over an \emph{alphabet} $A$, i.e. $\alpha \in
A^\omega$, can be seen as a function $\alpha\colon \mathbb{N}_{> 0} \to A$. Thus, we
write $\alpha(i)$ to refer to the $i$-th letter from $\alpha$. We also write
$\alpha(i..j)$ to denote the infix
$\alpha(i)\alpha(i+1)\dots\alpha(j-1)\alpha(j)$; $\alpha(..j)$ instead of
$\alpha(1..j)$; and $\alpha(i..)$ to denote the infinite suffix
$\alpha(i)\alpha(i+1)\dots$

\subsection{B\"uchi and parity automata}
\begin{definition}[Infinite-word automata]
  An ($\omega$-word) \emph{automaton} is a tuple $\calN =
  (Q,q_0,A,\Delta)$ where $Q$ is a finite set of states, $q_0 \in Q$ is the
  initial state, $A$ is a finite alphabet, and $\Delta \subseteq Q \times A
  \times Q$ is the transition relation. Since we are interested in infinite
  words, we will henceforth assume that for all $p \in Q$ and all $a \in A$
  there exists $q \in Q$ such that $(p,a,q) \in Q$.
\end{definition}
A run of $\calN$ on a word $\alpha \in A^\omega$ is an infinite sequence $\rho =
q_0 \alpha(1) q_1 \alpha(2) \dots \in (Q\cdot A)^\omega$ such that
$(q_i,\alpha(i+1),q_{i+1}) \in \Delta$ for all $i \in \mathbb{N}$. The automaton
is said to be \emph{deterministic} if for all $p \in Q$ and all $a \in A$ we
have that $(p,a,q_1), (p,a,q_2) \in \Delta$ implies $q_1 = q_2$.

Automata are equipped with a condition which determines which runs are
\emph{accepting}.  We put this extra information in the defining tuple of the
automaton (e.g., \(\calN = (Q, q_0, A, \Delta, U)\).  In this work we will
consider three conditions.
\begin{itemize}
  \item The \emph{safety} condition is defined with respect to a set $U
    \subseteq Q$ of \emph{unsafe states}. A run $\rho = q_0 a_1 q_1 a_2 \dots$
    is accepting for this condition, or safe, if and only if for all $i \in
    \mathbb{N}$ we have that $q_i \not\in U$.
  \item The \emph{B\"uchi} condition is defined with respect to a set of
    \emph{B\"uchi} states $B \subseteq Q$. A run $\rho = q_0
    a_1 q_1 a_2 \dots$ is accepting for this condition if and only if for
    all $i \in \mathbb{N}$ there exists $j \ge i$ such that $q_j \in B$.
    That is, the run visits B\"uchi states infinitely often.  The parity
    condition can be implemented using a B端chi condition by doing some simple
    modifications on the underlying automaton.
    %% This is "needed" for the claim that every game is memoryless determined.
  \item The \emph{parity} condition is defined with respect to a
    \emph{priority function} $p\colon Q \to \mathbb{N}$. A run $\rho = q_0 a_1
    q_1 a_2 \dots$ is accepting for the parity condition if and only if the
    value $\liminf_{i \to \infty} p(q_i)$ is even.
\end{itemize}
A word $\alpha$ is accepted by the automaton $\calN$ if it has a run on $\alpha$
that is accepting.  The \emph{co-} variant of each model (e.g., co-B端chi
automaton) negates the condition, that is, it turns accepting runs into
rejecting ones, and vice versa.  The \emph{universal} variant
of each model (e.g., universal B端chi automaton) accepts a word if \emph{all} the
runs on the word are accepting.

We denote by $\lang{\calN}$ the \emph{language} of the automaton $\calN$, that
is, the set of words that $\calN$ accepts.

In this work we will see some states of our automata as ``bad'' and want to
ensure that no run on a given word visits them infinitely often.  Thus, the
variant we are most interested in is \emph{universal co-B端chi automata}, in
which a word is accepted if all its runs visit a prescribed set of states only
finitely often.

Finally, we note that deterministic parity automata generalize the other
conditions in the following sense:
\begin{proposition}[From~\cite{safra88,piterman07}]\label{prop:paritymr}
  For all (nondeterministic) B\"uchi automata $\calN$ there exists a
  deterministic parity automaton $\calD$ of exponential size with respect to the
  size of $\calN$ such that $\lang{\calN} = \lang{\calD}$.
\end{proposition}

\subsection{Synthesis games and strategies}
\begin{definition}[Games]
  A \emph{(Gale-Stewart) game} on input and output alphabets $I$ and $O$,
  respectively, is a two-player perfect-information game played by \eve and
  \adam in rounds: \adam chooses an element $i_k \in I$ and \eve responds with
  an element $o_k \in O$. A \emph{play} in such a game is an infinite word
  $\langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots \in (I\times O)^\omega$. 
\end{definition}
A game is paired with a \emph{payoff set} $P \subseteq (I \times
O)^\omega$ used to determine who wins a play $\pi$. If $\pi \in P$ then
\emph{$\pi$ is winning for \eve}, otherwise it is \emph{winning for \adam}.

\begin{definition}[Strategies]
  A \emph{strategy} for \adam is a function $\tau\colon (I \times O)^*
  \to I$ which maps every (possibly empty) play prefix
  to a choice of input letter.  Similarly, a \emph{strategy for \eve}
  is a function $\sigma\colon (I \times O)^* I \to O$ which maps every play prefix
  and input letter to a choice of output letter.
\end{definition}
A play $\pi = \langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots$ is
\emph{consistent with} a strategy $\tau$ for \adam if $i_k = \tau( \langle
i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle)$ for all $k \in
\mathbb{N}$; it is consistent with a strategy $\sigma$ for \eve if $o_k =
\sigma( \langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle,
i_{k})$.  A pair of strategies $\sigma$ and $\tau$ for \eve and \adam,
respectively, induces a unique play $\out{\sigma}{\tau}$ consistent with both
$\sigma$ and $\tau$.

\paragraph*{Winning strategies.}
In a game with payoff set $P$, the strategy $\sigma$ for \eve is a \emph{winning
strategy} if for all strategies $\tau$ for \adam it holds that
$\out{\sigma}{\tau} \in P$; the strategy $\tau$ for \adam is winning if for all
strategies $\sigma$ for \eve we have $\out{\sigma}{\tau} \not\in P$.

\begin{proposition}[Borel determinacy~\cite{martin75}]
  For all games with Borel-definable payoff set $P$, it holds that there
  exists a winning strategy for \adam in the game if and only if there exists
  no winning strategy for \eve in the game.  Such games are said to be \emph{determined.}
\end{proposition}
We observe that all payoff sets induced by automata we consider in this work
are indeed Borel definable. It follows that all the games we will study are
determined.

\subsection{Realizability and synthesis}
The realizability and synthesis problems are defined for games whose payoff sets
are given as the language of an automaton. We sometimes refer to these as
\emph{games played on automata}.
\begin{definition}[Problems]
  Consider finite input and output alphabets $I$ and $O$, respectively, and
  an automaton $\calN$ with alphabet $I \times O$.
  The \emph{realizability problem} asks whether
  there exists a winning strategy for \eve in the game with payoff set 
  $\lang{\calN}$. The \emph{synthesis problem}
  further asks to compute and output such a strategy if one exists.
\end{definition}

\paragraph{Finite-memory strategies.}
A \emph{finite-memory} strategy $\sigma$ for \eve in a game played on the
automaton $\calN = (Q,q_0,I \times O,\Delta)$ with finite input and output
alphabets $I$ and $O$ is a strategy that can be encoded as a
\emph{(deterministic) Mealy machine}, that is, a finite-state machine that
outputs a letter from \(O\) when given a letter from \(I\).  Formally, such a
machine is a tuple $\calM = (S,s_0,I, \lambda_u,\lambda_o)$ where $S$ is a
finite set of (memory) states, $s_0$ is the initial state,
$\lambda_u\colon S \times (Q \times I) \to S$ is the update function and
$\lambda_o\colon S \times (Q \times I) \to O$ is the output function. The
machine encodes $\sigma$ in the following way. For all play prefixes
$\langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1} \rangle$ and input
letters $i_k \in I$ we have that
$\sigma(\langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1} \rangle, i_k) =
\lambda_o(s_k,i_k)$ where $s_{\ell + 1} = \lambda_u(s_\ell,i_\ell)$ for all
$\ell < k$. We then say the strategy $\sigma$ has \emph{memory} $|S|$. In
particular, when $|S| = 1$, we say the strategy is \emph{memoryless} (the term
\emph{positional} is also used in the literature).

\begin{proposition}[Memoryless determinacy for parity games~\cite{ag11}]
  \label{prop:det}%
  For all games played on deterministic parity automata, it holds that there
  exists a winning strategy for \eve in the game if and only if there exists a
  memoryless winning strategy for \eve.
\end{proposition}
Since the parity condition generalizes all the other conditions we consider in
this work, the above proposition implies memoryless determinacy for all our
games.  In particular, by \Cref{prop:paritymr}, games played on B端chi and safety
automata are also memoryless determined.

\section{Universal co-B\"uchi games}
In this section we present the Acacia~\cite{acacia} solution for the
realizability and synthesis problems for games played on (i.e. with payoff sets
expressed by) universal co-B\"uchi (UcB) automata.  Recall that these automata
deem a word accepted if no run on the word visits a B\"uchi state infinitely
often.  We consider a stronger version of this acceptance condition which asks
that visits to B\"uchi states be bounded by an explicit constant.

\begin{definition}[Universal \(K\)-co-B端chi automata]
  A universal $K$-co-B\"uchi (UKcB) automaton is a universal co-B端chi automaton
  $\calN = (Q,q_0,A,\Delta,B)$ with $B \subseteq Q$ the set of B\"uchi
  states.  It accepts a word $\alpha$ if and only if all of its runs
  $\rho = q_0 \alpha(1) q_1 \alpha(2) \dots$ on $\alpha$ visit at most $K$
  B\"uchi states, i.e. $|\{i \in \mathbb{N} : q_i \in B\}| < K$.
\end{definition}

Our intention is to give an incremental algorithm to solve games played on UcB
automata by solving the game played on the same automaton with UKcB semantics
for increasing values of $K$.  Note that a UcB automaton does not have to be
UKcB for any value of \(K\).  However, for any UcB automaton \(\calN\), there is
a value \(K\) for which the games played on \(\calN\) with UcB and UKcB semantics
are the same, in that they admit the same winning strategies.

Instead of working with UKcB automata directly, we will define equivalent
universal safety automata where counting up to \(K\) is embedded in the states.
As a starting point, with \(K = 1\), a UKcB is but a universal safety automaton:
as soon as a B\"uchi state is reached, the word should be
rejected. We extend this analogy for values
of \(K \geq 1\) by having this universal safety automaton count, up to \(K\), the
number of times B\"uchi states are visited.  At the same time, we
\emph{determinize} this automaton using a powerset-like construction, and only
keep, for each state \(q\) of \(\calN\), the \emph{maximum} number of B\"uchi
states visited upon reaching \(q\).  In practice, each state of our
safety automaton will be a function
\(f\colon Q \to \{0, \dots, K\} \cup \{\bot\}\); if a word reaches \(f\) with, say,
\(f(q) = i\), \(0 \leq i < K \), then the same word can reach \(q\) in
\(\calN\), never visiting more than \(i\) B\"uchi states.
\begin{definition}[$K$-bounded safety automaton]
  For a given UcB automaton $\calN = (Q,q_0,A,\Delta,B)$ and $K \in \mathbb{N}$,
  let $\calS^K_\calN$ be the deterministic safety
  automaton $(\calF,f_0,A,T,U)$ with components defined as follows.
  \begin{itemize}
    \item $\calF := \{f \colon Q \to \{0,\dots,K \} \cup
      \{\bot\}\}$,
      which is a finite set of functions,
    \item $f_0 \in \calF$ is such that $f_0(q_0) = 0$ and $f_0(q) =
      \bot$ for all $q \in Q$ such that $q \neq q_0$,
    \item $T$ consists of all triples $(f,a,g)$ such that for all $q \in Q$ we
      have
      \[
        g(q) = \max_{(p,a,q) \in \Delta}
        f(p) + \indicator{B}{q}
      \]
      where $\bot < n$ and $\bot + n = \bot$, for all $n \in \mathbb{N}$, and
      $K + 1 = K$.  If the \(\max\) is taken over an empty set, its value is \(\bot\).
    \item $U := \{ f \in \calF \mid f(q) = K \text{ for
      some } q \in Q \}$, the unsafe states.
  \end{itemize}
  The automaton $\calS^K_\calN$ accepts a word $\alpha$ if and only if its only
  run $f_0 \alpha(1) f_1 \alpha(2) \dots$ on $\alpha$ visits no state from $U$,
  i.e. $\forall i \in \mathbb{N} : f_i \not\in U$.
\end{definition}

The following property of $\calS^K_\calN$ follows from a straightforward
induction.
\begin{lemma}\label{lem:runs-visits}
  Let $\alpha \in A^\omega$ and $f_0 \alpha(1) f_1 \alpha(2) \dots$ be the
  unique run of $\calS^K_\calN$ on $\alpha$. For all $i \in \mathbb{N}$ and
  all $q \in Q$, if $f_i(q) \neq \bot$ then there exists a run $q_0
  \alpha(1) q_1 \alpha(2) \dots$ of $\calN$ on $\alpha$ such that $q_i = q$
  and $f_i(q) \leq |\{0 \leq j \leq i : q_j \in B\}|$.
\end{lemma}
%
The converse holds for large enough $K$ (see \Cref{lem:converse}).
The following is immediate from the lemma.
%
\begin{corollary}\label{cor:safe-approx}
  For all $\alpha \in A^\omega$ and all $K,\ell \in \mathbb{N}$ with $\ell
  \leq K$, if there exists a run of $\calN$ on $\alpha$ which visits 
  at least $K$ B\"uchi states then $\alpha \not\in \lang{\calS^\ell_\calN}$.
  In addition, the
  language of \(\calS^K_\calN\) is that of \(\calN\) with UKcB semantics,
  hence \(\lang{\calS^K_\calN} \subseteq \lang{\calN}\).
\end{corollary}

The second part of the above corollary allows us to argue that \eve winning
the game played on $\calS^K_\calN$ implies she wins the game played on
$\calN$.
\begin{lemma}
    Consider input and output alphabets $I$ and $O$, a UcB
    automaton $\calN$ with alphabet $I \times O$, a bound $K \in \mathbb{N}$,
    and the corresponding safety automaton $\calS^K_\calN$. A
    winning strategy for \eve in the game played on $\calS^K_\calN$
    is also a winning strategy for \eve in the game played on
    $\calN$.
\end{lemma}
\begin{proof}
  Consider a winning strategy \(\sigma\) for \eve in the game played on
  \(\calS^K_\calN\).  Any play \(\pi\) consistent with \(\sigma\) is such that
  \(\pi \in \lang{\calS^K_\calN}\), and by \Cref{cor:safe-approx},
  \(\pi \in \lang{\calN}\), showing that \(\sigma\) is a winning strategy for
  \eve in the game played on \(\calN\).\qed
\end{proof}

More interestingly, there exists a bound $K$ such that if \eve wins
the game played on $\calN$ then she also wins the one played on
$\calS^K_\calN$.  This relies on the memoryless determinacy of our games.
%
\begin{lemma}\label{lem:converse}
    Consider input and output alphabets $I$ and $O$ and a UcB automaton
    $\calN$ with alphabet $I \times O$. There exists a bound $K \in
    \mathbb{N}$, exponential with respect to the size of $\calN$, such that if
    there exists a winning strategy for \eve in the game played on $\calN$
    then there exists a winning strategy for \eve in the game played on
    $\calS^K_\calN$.
\end{lemma}
\begin{proof}[Sketch]
  Recall that every B\"uchi automaton can be ``determinized'' into a parity
  automaton of size at most exponential~\cite{safra88,piterman07}.  Let us
  consider a deterministic parity automaton $\calD$ such that
  $\lang{\calD} = \lang{\calN}$ and let $\sigma$ be the winning strategy for \eve in
  the game played on $\calN$ (and in the game played on $\calD$). By memoryless
  determinacy of parity games, there is a memoryless strategy $\mu$ for \eve in
  the game played on $\calD$. Since $\calD$ has exponential size with respect to
  the size of $\calN$, there exists an exponential-memory strategy $\mu'$ for \eve
  in the game played on $\calN$. It follows that if any run of $\calN$ on a play
  $\pi$ consistent with $\mu'$ has visited sufficiently many B\"uchi states, the
  Mealy machine realizing $\mu'$ must have revisited some configuration. Hence, by
  ``pumping'' this behaviour, \adam must be able to win against $\mu'$,
  contradicting the fact that $\mu'$ is a winning strategy for \eve. We thus have
  an exponential upper bound on visits to B\"uchi states for all runs on plays
  consistent with $\mu'$. By construction of $\calS^K_\calN$ we have that $\mu'$ is
  a winning strategy for \eve in the game played on $\calS^K_\calN$.  \qed
\end{proof}

\subsection{Some unsafe states are more unsafe than others}\label{sec:order}
There is a natural order on the states $f$ of $\calS^K_N$ induced by how many
times runs reaching each state $q$ with $f(q) \neq \bot$ have visited
B\"uchi states. Formally, let us define the partial order $f \preceq g$
to hold if and only if for all $q \in Q$ we have $f(q) \leq g(q)$.

We say a state $q \in Q$ of a safety automaton $\calS$ is \emph{winning for \eve}
if she has a winning strategy from it --- that is, in the game played on
\(\calS\) where the initial state is set to \(q\). Otherwise, the
state is losing for her. It follows from Lemma~\ref{lem:runs-visits} that the set of
winning states from $\calS^K_\calN$ is \emph{$\preceq$-downward closed}. We further
observe that $U$, the set of unsafe states of \(\calS^K_\calN\), is
\emph{$\preceq$-downward closed}.
\begin{proposition}\label{pro:down-closed}
  Let $f,g \in \mathcal{F}$ be states from $\calS^K_\calN$ such that $f
  \preceq g$.
  \begin{itemize}
    \item If $f \in U$ then $g \in U$.
    \item If $g$ is winning for \eve then $f$ is also winning for her.
  \end{itemize}
\end{proposition}

In the next section we recall the classical backwards algorithm for solving
safety and reachability games. We will give the algorithm directly for
$\calS^K_\calN$ and then state the necessary preliminaries for the symbolic
antichain-based algorithm to be presented.

\section{Solving safety games}
We refer to a game played on a \emph{deterministic} safety automaton as a safety
game. Let us first consider safety games without making use of the partial order
on the states of \(\calS^K_\calN\).

\subsection{Explicit algorithm}
For this section, let $\calS = (Q,q_0, I \times O, \Delta, U)$ be a safety
game and let us write $\Delta(q,\langle i, o \rangle)$ for the unique state
$q' \in Q$ such that $(q, \langle i, o \rangle, q') \in \Delta$.

\paragraph{Controllable predecessors.} The algorithm we describe
consists in iteratively applying a monotonically subset-increasing operator to
the set $Q \setminus U$ of safe states. The operator $\cpre\colon \pow{Q} \to \pow{Q}$ is
defined for all $S \subseteq Q$ as follows.
\[
  \cpre(S) := S \cap \{s \in Q \mid \exists i \in I, \forall o \in O :
  \Delta(s,\langle i, o \rangle) \in S\}
\]
Then, we inductively define $\cpre^n(S)$ for all $n \in \mathbb{N}$ by setting
$\cpre^0(S)$ to $S$ and $\cpre^{n+1}(S)$ to $\cpre(\cpre^{n}(S))$.
The following is immediate from the definitions.
\begin{lemma}
  Let $S \subseteq Q$ and $m, n \in \mathbb{N}$ such that $m \leq n$. Then,
  $\cpre^n(S) \subseteq \cpre^m(S) \subseteq S$.
\end{lemma}
It follows that the $\cpre^i(S)$ eventually stabilize
from some $i \leq |S|$ onward. Let us write $\cpre^*(S)$ for said \emph{fixed point}
of $\cpre$.

It is not hard to prove by induction that $\cpre^*(Q \setminus U)$ coincides with the set
of states which are winning for \eve.
\begin{proposition}
  A state $q \in Q$ is winning for \eve if and only if $q \in \cpre^*(Q
  \setminus U)$.
\end{proposition}

In the rest of this section we introduce a ``symbolic'' version of the $\cpre$
operator which leverages the $\preceq$ ordering on states of $\calS^K_\calN$.

\subsection{Antichain-based algorithm}
We intend to leverage~\Cref{pro:down-closed} to define an operator
which manipulates \emph{maximal elements} of the sets only and, crucially,
preserves downward-closedness of all intermediate sets. We first give some
preliminaries regarding antichains.

\paragraph{Lattices and antichains.} A partially ordered set $(S, \preceq)$ is
an \emph{lower semilattice} if the \emph{greatest lower bound} of any nonempty
finite subset of $S$ is an element of $S$. Given $s,s' \in S$, we write $s
\sqcap s'$ for the greatest lower bound of $\{s,s'\}$. We extend this notation
to subsets $S', S'' \subseteq S$ and write
$S \sqcap S'$ for $\{s' \sqcap s'' \mid s' \in S', s'' \in S''\}$. 
Note that the partially ordered set $(\calF,\preceq)$ we have defined in
\Cref{sec:order} is a lower semilattice. Indeed, for $f, g \in \calF$ we have
that $f \sqcap g$ is a function $\phi \in \calF$ such that
\(
  \phi(q) = \min(f(q),g(q))
\)
for all $q \in Q$.

A subset $A \subseteq S$ is called an \emph{antichain} if all its elements are
pairwise $\preceq$-incomparable.  Given $S' \subseteq S$, we write $\lceil S'
\rceil$ for the antichain of $\preceq$-maximal elements of $S$. We say that
$S'$ is (downward-)closed if $s' \in S'$ and $s'' \preceq s'$ implies that $s''
\in S'$. Finally, we write $\closedn{S''}$ to denote the (downward-)closure of
$S'' \subseteq S$, that is to say the set $\{s \in S \mid \exists s'' \in S''
: s \preceq s''\}$.  It is immediate to check that if \(S\) is closed, then
\(S = \closedn{\lceil S \rceil}\); in that sense, we will say that \(S\) is
\emph{represented by} the set of its maximal elements \(\lceil S \rceil\).

The result below already captures the intuition of the developments that will
follow in this section. We will use antichains as a ``data structure'' to
represent closed sets and will operate on them instead of their closure to
compute the set of winning states for \eve.
\begin{proposition}[From~\cite{dr10}]\label{pro:antichains}
  Let $(S, \preceq)$ be a lower semilattice, and $R,R' \subseteq S$ be two
  closed sets represented by the antichains $A = \lceil R \rceil, A' =
  \lceil R' \rceil$. The following hold:
  \begin{itemize}
    \item $R \cup R'$ is closed and $\lceil R \cup R' \rceil = \lceil A
      \cup A'\rceil$, and
    \item $R \cap R'$ is closed and $\lceil R \cap R' \rceil = \lceil A
      \sqcap A'\rceil$.
  \end{itemize}
\end{proposition}

\paragraph{Antichain-based controllable predecessors.}
Henceforth, we fix a safety
automaton $\calS^K_\calN = (\calF,f_0,I \times O, T,U)$.  Previously, we have given a
definition for $\cpre$ in the context of any safety game. For the safety game
played on $\calS^K_\calN$ and for a set $F \subseteq \calF$, $\cpre$ can equivalently be
defined as follows.
\[
  \cpre(F) = F \cap \left( \bigcup_{i \in I} \bigcap_{o \in O}
  \{f \in \calF \mid T(f,\langle i, o \rangle) \in F\} \right)
\]
%
Let us write $\frakA \subseteq \pow{\calF}$ for the set of all antichains. In
the next lemma, we will argue that if $F$ is closed and $A = \lceil F \rceil$
then $\cpre(F)$ can be replaced by the closure of $\underline{\cpre} \colon
\frakA \to \frakA$, defined below, applied to $A$.
\begin{align*}
  A^{(0)}_{i,o} := {} &
  \left\lceil \bigcup_{m \in A} \{f \in \calF \mid T(f,\langle i, o \rangle)
  \preceq m \} \right\rceil\\
  %
  A^{(1)}_{i} := {} &
  \left\lceil \bigsqcap_{o \in O} A^{(0)}_{i,o} \right\rceil\\
  %
  A^{(2)} := {} &
  \left\lceil \bigcup_{i \in I} A^{(1)}_i \right\rceil\\
  %
  \underline{\cpre}(A) := {} &
  \lceil A \sqcap A^{(2)} \rceil
\end{align*}
We inductively define $\underline{\cpre}^n(A)$, for all $n \in \mathbb{N}$, as
we did for $\cpre$. Since $\frakA$ is finite, we also have that the
$\underline{\cpre}^i(A)$ stabilize from some $i \leq 2^{|Q|}$ onward. We write
$\underline{\cpre}^*(A)$ for said fixed point of $\underline{\cpre}$.


\begin{lemma}
  Let $F \subseteq \calF$ be a closed set represented by the antichain $A =
  \lceil F \rceil$. Then $\cpre(F)$ is closed and
  \(
    \cpre(F) = \closedn{\underline{\cpre}(A)}.
  \)
\end{lemma}
The next equality follows from the facts that
$F$ is closed and $A = \lceil F \rceil$.
\begin{equation}\label{eqn:in-f}
  \bigcup_{m \in A} \{ f \in \calF \mid T(f, \langle i,o \rangle) \preceq m
  \}
  =
  \{f \in \calF \mid T(f,\langle i, o \rangle) \in F\}
\end{equation}
Hence, from \Cref{pro:antichains} and the definitions of $\cpre$,
$\underline{\cpre}$, and $A^{(0)}_{i,o}$, it follows that proving
the left-hand side of~\eqref{eqn:in-f} is closed suffices for the lemma to
hold.
\begin{lemma}\label{lem:closed-pre}
  Let $i \in I$, $o \in O$, and $m \in \calF$.  Then $\{f \in \calF \mid m
  \preceq T(f, \langle i,o \rangle) \}$ is closed.
\end{lemma}
\begin{proof}
  Consider an arbitrary $f$ in the set and some $f' \in \calF$ such that $f'
  \preceq f$. It is easy to see that, by definition of the transition
  function $T$ of $\calS^K_\calN$, we have 
  \[ 
    T(f',\langle i, o \rangle) \preceq T(f,\langle i, o \rangle)
  \]
  Further, $T(f,\langle i, o \rangle) \preceq m$ holds by assumption. Hence
  \(T(f', \langle i, o \rangle) \preceq m\) and $f'$ is also in the set.\qed
\end{proof}

From the above lemmas and~\Cref{pro:down-closed} it follows that one can compute the set of
losing states for \eve using $\underline{\cpre}$.
\begin{theorem}
  A state $f \in \calF$ is winning for \eve if and only if $f \in
  \closedn{\underline{\cpre}^*(\lceil Q \setminus U \rceil)}$.
\end{theorem}

Note that in computing $\underline{\cpre}^*(\lceil Q \setminus U \rceil)$, the only
intermediate set for which it is not immediately clear that we can compute it
based on an antichain of maximal elements is $A^{(0)}_{i,o}$. Indeed,
$A^{(1)}_i$ and $A^{(2)}$ can be computed from the antichain representation of
a closed set using the equivalences stated in \Cref{pro:antichains}. To avoid
computing the set of all direct predecessors of $\closedn{A}$ to compute $A^{(0)}_{i,o}$
we introduce a ``pseudo-inverse'' $\pseudopre : \calF \times I \times O \to
\calF$ of $T$ defined below for all $f \in \calF$, all $i \in I$, and all $o
\in O$. For convenience, we adopt the convention that $0 - 1 = 0$ and
$\bot - 1 = \bot$.
\[
  \pseudopre(f,i,o) := \left\{ p \mapsto
    \min_{(p,\langle i, o \rangle,q) \in \Delta} f(q) -
    \indicator{B}{q} \right\}
\]

\begin{lemma}[From~\cite{acacia0}]\label{lem:order-pseudopre}
  For all $f,g \in \calF$, all $i \in I$, and all $o \in O$
  the following hold.
  \begin{enumerate}
    \item $f \preceq g \implies \pseudopre(f,i,o) \preceq \pseudopre(g,i,o)$
      \label{itm:order-pre}
    \item $f \preceq \pseudopre(T(f,\langle i, o \rangle),i,o)$
      \label{itm:order-postpre}
    \item $T(\pseudopre(f,i,o), \langle i, o \rangle) \preceq f$
      \label{itm:order-prepost}
  \end{enumerate}
\end{lemma}

We now claim that $A^{(0)}_{i,o}$ can be more efficiently computed using
$\pseudopre(m,i,o)$. That is, it allows us to avoid constructing the full
closure of $A$ to compute $A^{(0)}_{i,o}$. A formal statement follows.

\begin{proposition}[From~\cite{acacia0}]
  Let $m \in \calF$, $i \in I$, $o \in O$. Then, the following equivalence
  holds:
  \[
    \{ f \in \calF \mid T(f, \langle i,
    o \rangle) \preceq m\} = \closedn{\pseudopre(m,i,o)}.
  \]
\end{proposition}
\begin{proof}[Sketch]
  Using \Cref{lem:order-pseudopre} and the fact that $T$ is $\preceq$-monotone,
  both inclusions can be easily derived.
\end{proof}

We close this section with an impossibility result. While computing
$\underline{\cpre}$ is, intuitively, more efficient than computing $\cpre$, it
turns out that it is computationally hard. One can reduce the computation of
all maximal-size independent sets of a graph to the computation of
$\underline{\cpre}$ for a safety game on functions as studied in this section.
\begin{proposition}[From~\cite{acacia0}]
  The $\underline{\cpre}$ operator is, in general, not computable in
  polynomial time unless $\NP = \P$.
\end{proposition}

\section{Antichain data structures}
\todo[inline]{DO RESEARCH}

\todo[inline]{Computing $\underline{\cpre}$ cannot be done in polynomial time
  unless the maximal independent set problem is in polynomial time;
  interestingly, that problem admits polynomial-time approximation algorithms
for polynomial approximations (i.e. not constant)}



\bibliographystyle{splncs04}
\bibliography{refs}

\end{document}

% LocalWords:  memoryless B端chi
