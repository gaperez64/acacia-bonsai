\documentclass[runningheads,a4paper,draft]{llncs}

\usepackage{amssymb,amstext}
\usepackage{xspace}
\usepackage{todonotes}

% Usual math notation fixes
\makeatletter
\let\epsilon\varepsilon
\let\phi\varphi
\let\emptyset\varnothing
\makeatother

% Local macros
\newcommand{\indicator}[2]{\mathbf{1}_{#1}(#2)}
\newcommand{\pow}{\mathcal{P}}
\newcommand{\upre}{\mathbf{UPre}}
\newcommand{\eve}{Eve\xspace}
\newcommand{\adam}{Adam\xspace}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\lang}[1]{\mathcal{L}({#1})}
\newcommand{\out}[2]{\pi_{#1#2}}

\begin{document}

\title{Acacia Bonsai: A Minimal Implementation of Antichain-Based Algorithms
for LTL Synthesis}
\titlerunning{Acacia Bonsai: LTL Synthesis with Antichains}

\author{Micha\"el Cadilhac\inst{1} \and
Guillermo A. P\'erez\inst{2}} %\orcidID{0000-0002-1200-4952}}
\institute{DePaul University, U.S.A.\\
\email{michael@cadilhac.name} \and
University of Antwerp, Belgium\\
\email{guillermoalberto.perez@uantwerpen.be}
}
\authorrunning{G. A. P\'erez \and M. Cadilhac}

\maketitle

\begin{abstract}
  We describe our re-implementation of antichain-based algorithms used to
  solve the reactive synthesis problem with linear temporal logic (LTL)
  specifications. Formally, we study Gale-Stewart games played between an
  input and an output player (called \adam and \eve, respectively) and with
  payoff set being the complement of the language of a given B\"uchi
  automaton: if the infinite input-output sequence is accepted by the
  automaton, then \adam wins, otherwise \eve wins. To efficiently compute a
  winning strategy for one of the players, we use antichains as a symbolic
  representation of closed sets of configurations of the game.
  \keywords{Reactive synthesis \and LTL \and Antichains \and Data structures}
\end{abstract}

\section{Definitions}
An \emph{infinite word} $\alpha$ over an \emph{alphabet} $A$, i.e. $\alpha \in
A^\omega$, can be seen as a function $\alpha : \mathbb{N}_{> 0} \to A$. Thus, we
write $\alpha(i)$ to refer to the $i$-th letter from $\alpha$. We also write
$\alpha(i..j)$ to denote the infix
$\alpha(i)\alpha(i+1)\dots\alpha(j-1)\alpha(j)$; $\alpha(..j)$ instead of
$\alpha(1..j)$; and $\alpha(i..)$ to denote the infinite suffix
$\alpha(i)\alpha(i+1)\dots$

\subsection{B\"uchi and parity automata}
\begin{definition}[Infinite-word automata]
  An ($\omega$-word) \emph{automaton} is a tuple $\calN =
  (Q,q_0,A,\Delta)$ where $Q$ is a finite set of states, $q_0 \in Q$ is the
  initial state, $A$ is a finite alphabet, and $\Delta \subseteq Q \times A
  \times Q$ is the transition relation. Since we are interested in infinite
  words, we will henceforth assume that for all $p \in Q$ and all $a \in A$
  there exists $q \in Q$ such that $(p,a,q) \in Q$.
\end{definition}
A run of $\calN$ on a word $\alpha \in A^\omega$ is an infinite sequence $\rho =
q_0 \alpha(1) q_1 \alpha(2) \dots \in (Q\cdot A)^\omega$ such that
$(q_i,\alpha(i+1),q_{i+1}) \in \Delta$ for all $i \in \mathbb{N}$. The automaton
is said to be \emph{deterministic} if for all $p \in Q$ and all $a \in A$ we
have that $(p,a,q_1), (p,a,q_2) \in \Delta$ implies $q_1 = q_2$.

Automata are paired with a condition which determines which runs are
\emph{accepting}. In this work we will consider two conditions.
\begin{itemize}
  \item The \emph{safety} condition is defined with respect to a set $U
    \subseteq Q$ of \emph{unsafe states}. A run $\rho = q_0 a_1 q_1 a_2 \dots$
    is accepting for this condition, or safe, if and only if for all $i \in
    \mathbb{N}$ we have that $q_i \not\in U$.
  \item The \emph{B\"uchi} condition is defined with respect to a set of
    \emph{B\"uchi} or accepting states $B \subseteq Q$. A run $\rho = q_0
    a_1 q_1 a_2 \dots$ is accepting for this condition if and only if for
    all $i \in \mathbb{N}$ there exists $j \ge i$ such that $q_j \in B$.
    That is, the run visits accepting states infinitely often.
  \item The \emph{parity} condition is defined with respect to a
    \emph{priority function} $p : Q \to \mathbb{N}$. A run $\rho = q_0 a_1
    q_1 a_2 \dots$ is accepting for the parity condition if and only if the
    value $\liminf_{i \to \infty} p(q_i)$ is even.
\end{itemize}
A word $\alpha$ is accepted by the automaton $\calN$ if it has a run on
$\alpha$ that is accepting.  We denote by $\lang{\calN}$ the \emph{language} of
the automaton $\calN$, that is, the set of words that $\calN$ accepts.

\begin{proposition}[From~\cite{safra92,piterman07}]
  For all B\"uchi automata $\calN$ there exists a deterministic parity
  automaton $\calD$ of exponential size with respect to the size of $\calN$
  such that $\lang{\calN} = \lang{\calD}$.
\end{proposition}

In this work we will consider B\"uchi automata $\calN$ whose
language represent sets of ``bad'' words. Thus, rather than being interested in
the set $\lang{\calN}$, we will mostly focus on its complement. It will
therefore be convenient to view $\calN$ as a \emph{universal
co-B\"uchi automaton}. That is to say, an automaton that accepts a word $\alpha$
if all of its runs on $\alpha$ are \textbf{not} accepting with respect to the
B\"uchi condition. (In other words, all runs on $\alpha$ visit accepting states
only finitely often.)

\subsection{Synthesis games and strategies}
\begin{definition}[Games]
  A \emph{(Gale-Stewart) game} on input and output alphabets $I$ and $O$,
  respectively, is a two-player perfect-information game played by \eve and
  \adam in rounds: \adam chooses an element $i_k \in I$ and \eve responds with
  an element $o_k \in O$. A \emph{play} in such a game is an infinite word
  $\langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots \in (I\times O)^\omega$. 
\end{definition}
A game is paired with a \emph{payoff set} $P \subseteq (I \times
O)^\omega$ used to determine who wins a play $\pi$. If $\pi \in P$ then
\emph{$\pi$ is winning for \eve}, otherwise it is \emph{winning for \adam}.

\begin{definition}[Strategies]
  A \emph{strategy} for \adam in a game is a function $\tau : (I \times O)^*
  \to I$ which maps every (possibly empty) play prefix
  to a choice of input letter.  Similarly, a \emph{strategy for \eve}
  is a function $\sigma : (I \times O)^* I \to O$ which maps every play prefix
  and input letter to a choice of output letter.
\end{definition}
A play $\pi = \langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots$ is
\emph{consistent with} a strategy $\tau$ for \adam if $i_k = \tau( \langle
i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle)$ for all $k \in
\mathbb{N}$; it is consistent with a strategy $\sigma$ for \eve if $o_k =
\sigma( \langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle,
i_{k})$.  A pair of strategies $\sigma$ and $\tau$ for \eve and \adam,
respectively, induces a unique play $\out{\sigma}{\tau}$ consistent with both
$\sigma$ and $\tau$.

\paragraph*{Winning strategies.}
In a game with payoff set $P$, the strategy $\sigma$ for \eve is a \emph{winning
strategy} if for all strategies $\tau$ for \adam it holds that
$\out{\sigma}{\tau} \in P$; the strategy $\tau$ for \eve is winning if for all
strategies $\sigma$ for \eve we have $\out{\sigma}{\tau} \not\in P$.

\begin{proposition}[Borel determinacy~\cite{martin75}]
  For all games with Borel-definable payoff set $P$, it holds that there
  exists a winning strategy for \adam in the game if and only if there exists
  no winning strategy for \eve in the game.
\end{proposition}
We observe that all payoff sets induced by automata we consider in this work
are indeed Borel definable. It follows that all the games we will study are
determined.

\subsection{Realizability and synthesis}
The realizability and synthesis problems are defined for games whose payoff sets
are given as the language of an automaton. We sometimes refer to these as
\emph{games played on automata}.
\begin{definition}[Problems]
  Consider finite input and output alphabets $I$ and $O$, respectively, and
  an automaton $\calN$ with alphabet $I \times O$.
  The \emph{realizability problem} asks whether
  there exists a winning strategy for \eve in the game with payoff set 
  $\lang{\calN}$. The \emph{synthesis problem}
  further asks to compute and output such a strategy if one exists.
\end{definition}

\paragraph{Finite-memory strategies.}
A \emph{finite-memory} strategy $\sigma$ for \eve in a game played on the
automaton $\calN =
(Q,q_0,I \times O,\Delta)$ with finite input and
output alphabets $I$ and $O$ is a strategy that can be encoded as a
\emph{(deterministic) Mealy machine} $\calM = (S,s_0,I, \lambda_u,\lambda_o)$
where $S$ is a finite set of (memory) states, $s_0$ is the initial state,
$\lambda_u : S \times (Q \times I) \to S$ is the update function and $\lambda_o
: S \times (Q \times I) \to O$ is the output function. The machine encodes
$\sigma$ in the following way. For all play prefixes $\langle i_1,  o_1\rangle
\dots \langle i_{k-1}, o_{k-1} \rangle$ and input letters $i_k \in I$ we have
that $\sigma(\langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1} \rangle,
i_k) = \lambda_o(s_k,i_k)$ where $s_{\ell + 1} =
\lambda_u(s_\ell,i_\ell)$. We then say the strategy $\sigma$ has \emph{memory}
$|S|$. In particular, when $|S| = 1$, we say the strategy is \emph{memoryless}
or \emph{positional}.

\begin{proposition}[Memoryless determinacy for parity games~\cite{ag11}]
  For all games played on deterministic parity automata, it holds that there
  exists a winning strategy for \eve in the game if and only if there exists a
  memoryless winning strategy for \eve.
\end{proposition}
Since the parity condition generalizes all the other conditions we consider in
this work, the above proposition implies memoryless determinacy for all games
played on deterministic automata. In particular, games played on deterministic
safety automata are also memoryless determined.

\section{Universal co-B\"uchi games}
In this section we recall the Acacia~\cite{acacia} solution for the
realizability and synthesis problems for games played on universal co-B\"uchi
automata. Recall that these are games whose payoff set is given by a universal
co-B\"uchi (UcB) automaton.  From a given UcB automaton we will consider a
stronger version of its acceptance condition which asks that visits to
accepting states are bounded.

\begin{definition}[Universal $K$-co-B\"uchi automata]
  A universal $K$-co-B\"uchi (UKcB) automaton is an automaton $\calN =
  (Q,q_0,A,\Delta,B)$ that accepts a word $\alpha$ if and only if all of its
  runs $\rho = q_0 \alpha(1) q_1 \alpha(2) \dots$
  on $\alpha$ visit at most $K$ accepting states, i.e. $|\{i \in \mathbb{N} :
  q_i \in B\}| \le K$.
\end{definition}

Our intention is to give an incremental algorithm to solve games played on UcB
automata by solving the game played on the same automaton with UKcB semantics
for increasing values of $K$. As a first step, we will construct a
deterministic
safety automaton which keeps track of the maximal accepting-state visit
count per reachable state instead of doing so for each run.
\begin{definition}[$K$-co-B\"uchi safety automaton]
  For a given UcB automaton $\calN = (Q,q_0,A,\Delta,B)$ and $K \in
  \mathbb{N}$, let $\calS^K_\calN$ be the automaton $(\calF,f_0,A,T,U)$
  with components defined as follows.
  \begin{itemize}
    \item $\calF := \{f : Q \to \{0,\dots,K\} \cup
      \{\bot\}\}$,
    \item $f_0 \in \calF$ is such that $f_0(q_0) = 0$ and $f_0(q) =
      \bot$ for all $q \in Q$ such that $q \neq q_0$,
    \item $U := \{ f \in \calF \mid f(q) = K \text{ for
      some } q \in Q \}$,
    \item $T$ consists of all triples $(f,a,g)$ such that for all $q \in Q$ we
      have
      \[
        g(q) = \max_{(p,a,q) \in \Delta}
        f(p) + \indicator{U}{q}
      \]
      where $\bot < n$ and $\bot + n = \bot$, for all $n \in \mathbb{N}$, and
      $K + 1 = K$.
  \end{itemize}
  The automaton $\calS^K_\calN$ accepts a word $\alpha$ if and only if it has no
  run $q_0 \alpha(1) q_1 \alpha(2) \dots$ on $\alpha$ which visits a
  state from $U$, i.e. $\forall i \in \mathbb{N} : q_i \not\in U$ holds for all
  runs.
\end{definition}

The following property of $\calS^K_\calN$ follows from a
straightforward induction.
\begin{lemma}\label{lem:runs-visits}
  Let $\alpha \in A^\omega$ and $f_0 \alpha(1) f_1 \alpha(2) \dots$ be the
  unique run of $\calS^K_\calN$ on $\alpha$. For all $i \in \mathbb{N}$ and
  all $q_i \in Q$, if $f_i(q_i) \neq \bot$ then there exists a run $q_0
  \alpha(1) q_1 \alpha(2) \dots$ of $\calN$ on $\alpha$ which visits at least
  $f_i(q_i)$ accepting states.
\end{lemma}
%
The following is immediate from the lemma.
\begin{corollary}\label{cor:safe-approx}
  For all $\alpha \in A^\omega$ and all $K,\ell \in \mathbb{N}$ with $\ell
  \leq K$, if there exists a run $\rho$ of $\calN$ on $\alpha$ which visits
  at least $K$ accepting states then $\alpha \not\in \lang{\calS^\ell_\calN}$.
\end{corollary}

The above corollary allows us to argue that \eve winning the game played on
$\calS^K_\calN$ implies she wins the game played on $\calN$.
\begin{lemma}
    Consider input and output alphabets $I$ and $O$, a UcB
    automaton $\calN$ with alphabet $I \times O$, a bound $K \in \mathbb{N}$,
    and the corresponding universal safety automaton $\calS^K_\calN$. If there
    exists a winning strategy for \eve in the game played on $\calS^K_\calN$
    then there exists a winning strategy for \eve in the game played on
    $\calN$.
\end{lemma}
\begin{proof}
    We will argue the contraposition of the claimed implication holds.
    Note that $\lang{\calN}$ is clearly Borel definable. It follows that the
    game played on $\calN$ is determined and that, by assumption, there exists a
    winning strategy $\tau$ for \adam. Hence, any play $\pi$ consistent with
    $\tau$ will be such that $\pi \not\in \lang{\calN}$ and thus $\pi \not\in
    \lang{\calS^K_\calN}$ by Corollary~\ref{cor:safe-approx}.
    So $\tau$ is a winning strategy for \adam in the game
    played on $\calS^K_\calN$.
\qed\end{proof}

Conversely, there exists a large enough bound $K$ such that if \eve wins the game
played on $\calN$ then she also wins the one played on $\calS^K_\calN$.
%
\begin{lemma}
    Consider input and output alphabets $I$ and $O$ and a UcB automaton
    $\calN$ with alphabet $I \times O$. There exists a bound $K \in
    \mathbb{N}$, exponential with respect to the size of $\calN$, such that if
    there exists a winning strategy for \eve in the game played on $\calN$
    then there exists a winning strategy for \eve in the game played on
    $\calS^K_\calN$.
\end{lemma}
\begin{proof}[Sketch]
    Let us consider a deterministic parity automaton $\calD$ such that
    $\lang{\calD} = \lang{\calN}$ and let $\sigma$ be the winning strategy for
    \eve in the game played on $\calN$ (and in the game played on $\calD$). By
    memoryless determinacy of parity games, there is a memoryless strategy $\mu$
    for \eve in the game played on $\calD$. Since $\calD$ has exponential size
    with respect to the size of $\calN$, there exists an exponential-memory
    strategy $\mu'$ for \eve in the game played on $\calN$. It follows that if
    any run of $\calN$ on a play $\pi$ consistent with $\mu'$ has visited
    sufficiently many accepting states, the Mealy machine realizing $\mu'$ must
    have revisited some configuration. Hence, by ``pumping'' this behaviour,
    \adam must be able to win against $\mu'$, contradicting the fact that $\mu'$
    is a winning strategy for \eve. We thus have an exponential upper bound on
    visits to accepting states for all runs on plays consistent with $\mu'$. By
    construction of $\calS^K_\calN$ we have that $\mu'$ is a winning strategy for
    \eve in the game played on $\calS^K_\calN$.
\qed\end{proof}

\subsection{Some unsafe states are more unsafe than others}
There is a natural order on the states $f$ of $\calS^K_N$ induced by how many
times runs reaching each state $q$ with $f(q) \neq \bot$ have visited
accepting states. Formally, let us define the partial order $f \preceq g$
to hold if and only if for all $q \in Q$ we have $f(q) \leq g(q)$.

We say a state $q \in Q$ of a safety automaton $\calS$ is \emph{winning for
  \eve} if she has a winning strategy from it. Otherwise, the state is losing
for her. It follows from Lemma~\ref{lem:runs-visits} and determinacy of
safety games that the set of losing states from $\calS^K_\calN$ are
\emph{$\preceq$-upwards closed}. We further observe that $U$ itself is
$\preceq$-upwards closed.
\begin{proposition}\label{pro:up-closed}
  Let $f,g \in \mathcal{F}$ be states from $\calS^K_\calN$ such that $f
  \preceq g$.
  \begin{itemize}
    \item If $f \in U$ then $g \in U$.
    \item If $f$ is losing for \eve then $g$ is also losing for her.
  \end{itemize}
\end{proposition}

In the sequel we recall the classical backwards algorithm for solving safety
and reachability games. We will give the algorithm directly for
$\calS^K_\calN$ and then state the necessary preliminaries for the symbolic
antichain-based algorithm to be presented.

\section{Solving safety games}
We refer to a game played on a deterministic safety automaton as a safety
game. Let us first consider safety games without making use of the partial
order for our particular $K$-co-B\"uchi safety game.

\subsection{Explicit algorithm}
For this section, let $\calS = (Q,q_0, I\times O, \delta, U)$ be a safety
game and let us write $\delta(q,\langle i, o \rangle)$ for the unique state
$q' \in Q$ such that $(q, \langle i, o \rangle, q') \in \delta$.

\paragraph{Uncontrollable predecessors.} The algorithm we describe
consists in iteratively applying a monotonically subset-increasing operator to
the set $U$ of unsafe states. The operator $\upre : \pow{Q} \to \pow{Q}$ is
defined for all $S \subseteq Q$ as follows.
\[
  \upre(S) := S \cup \{s \in Q \mid \exists i \in I, \forall o \in O :
  \delta(s,\langle i, o \rangle) \in S\}
\]
Then, we inductively define $\upre^n(S)$ for all $n \in \mathbb{N}$ by setting
$\upre^0(S)$ to $S$ and $\upre^{n+1}(S)$ to $\upre(\upre^{n}(S))$.
The following is immediate from the definitions.
\begin{lemma}
  Let $S \subseteq Q$ and $n,m \in \mathbb{N}$ such that $n \leq m$. Then,
  $S \subseteq \upre^n(S) \subseteq \upre^m(S) \subseteq Q$.
\end{lemma}
Since $Q$ is finite, it follows that the $\upre^i(S)$ eventually stabilize
from some $i \leq |Q|$ onward.  Let us write $\upre^*(S)$ for said \emph{fixed point}
of $\upre$.

It is not hard to prove by induction that $\upre^*(U)$ coincides with the set
of states which are losing for \eve.
\begin{proposition}
  A state $q \in Q$ is losing for \eve if and only if $q \in \upre^*(U)$.
\end{proposition}

In the rest of this section we introduce a ``symbolic'' version of the $\upre$
operator which leverages the $\preceq$ ordering on states of $\calS^K_\calN$.

\subsection{Antichain-based algorithm}
We intend to leverage Proposition~\ref{pro:up-closed} to define an operator
which preserves upwards-closedness.
\todo[inline]{define the antichain-based algorithm}


\bibliographystyle{splncs04}
\bibliography{refs}{ }

\end{document}
