\documentclass[runningheads,a4paper,draft]{llncs}

\usepackage{amssymb,amstext}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage{cleveref}

% Usual math notation fixes
\makeatletter
\let\epsilon\varepsilon
\let\phi\varphi
\let\emptyset\varnothing
\makeatother

% Todonotes
\usepackage{todonotes,setspace,marginnote,xstring}
\newcounter{authornotes}
\newcommand\authornote[3][]{%
  \refstepcounter{authornotes}%
  {%
    \IfSubStr{,#1,}{,inline,}{}{\setstretch{0.7}}%
    \todo[size=\small,#1]{%
      \textbf{\uppercase{#2}\theauthornotes:}~#3}%
  }}
\newcommand\gpnote[2][]{\authornote[color={red!100!green!33},#1]{GP}{#2}}
\newcommand\mcnote[2][]{\authornote[color={blue!50!green!20},#1]{MC}{#2}}
\def\mathnote#1{{\let\marginpar\marginnote\textrm{\normalfont #1}}}

% Local macros
\newcommand{\indicator}[2]{\mathbf{1}_{#1}(#2)}
\newcommand{\pow}[1]{\mathcal{P}(#1)}
\newcommand{\upre}{\mathbf{UPre}}
\newcommand{\eve}{Eve\xspace}
\newcommand{\adam}{Adam\xspace}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\calM}{\mathcal{M}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calG}{\mathcal{G}}
\newcommand{\lang}[1]{\mathcal{L}({#1})}
\newcommand{\out}[2]{\pi_{#1#2}}

% Watermark
\usepackage{ifdraft}
\ifdraft{
  \usepackage{draftwatermark}
  \SetWatermarkAngle{0}
  \SetWatermarkLightness{0.7}
  \SetWatermarkFontSize{0.7cm}
  % \SetWatermarkHorCenter
  \SetWatermarkVerCenter{1cm}
  \usepackage{datetime2}
  %\DTMsetstyle{ddmmyy}
  \SetWatermarkText{{DRAFT  (comp. on: \DTMtoday, \DTMcurrenttime)}}
}

\begin{document}



\title{Acacia Bonsai: A Minimal Implementation of Antichain-Based Algorithms
for LTL Synthesis}
\titlerunning{Acacia Bonsai: LTL Synthesis with Antichains}

\author{Micha\"el Cadilhac\inst{1} \and
Guillermo A. P\'erez\inst{2}} %\orcidID{0000-0002-1200-4952}}
\institute{DePaul University, U.S.A.\\
\email{michael@cadilhac.name} \and
University of Antwerp, Belgium\\
\email{guillermoalberto.perez@uantwerpen.be}
}
\authorrunning{M. Cadilhac \and G. A. P\'erez}

\maketitle

\begin{abstract}
  We describe our re-implementation of antichain-based algorithms used to
  solve the reactive synthesis problem with linear temporal logic (LTL)
  specifications. Formally, we study Gale-Stewart games played between an
  input and an output player (called \adam and \eve, respectively) and with
  payoff set being the complement of the language of a given B\"uchi
  automaton: if the infinite input-output sequence is accepted by the
  automaton, then \adam wins, otherwise \eve wins. To efficiently compute a
  winning strategy for one of the players, we use antichains as a symbolic
  representation of closed sets of configurations of the game.
  \keywords{Reactive synthesis \and LTL \and Antichains \and Data structures}
\end{abstract}

\section{Definitions}
An \emph{infinite word} $\alpha$ over an \emph{alphabet} $A$, i.e. $\alpha \in
A^\omega$, can be seen as a function $\alpha\colon \mathbb{N}_{> 0} \to A$. Thus, we
write $\alpha(i)$ to refer to the $i$-th letter from $\alpha$. We also write
$\alpha(i..j)$ to denote the infix
$\alpha(i)\alpha(i+1)\dots\alpha(j-1)\alpha(j)$; $\alpha(..j)$ instead of
$\alpha(1..j)$; and $\alpha(i..)$ to denote the infinite suffix
$\alpha(i)\alpha(i+1)\dots$

\subsection{B\"uchi and parity automata}
\begin{definition}[Infinite-word automata]
  An ($\omega$-word) \emph{automaton} is a tuple $\calN =
  (Q,q_0,A,\Delta)$ where $Q$ is a finite set of states, $q_0 \in Q$ is the
  initial state, $A$ is a finite alphabet, and $\Delta \subseteq Q \times A
  \times Q$ is the transition relation. Since we are interested in infinite
  words, we will henceforth assume that for all $p \in Q$ and all $a \in A$
  there exists $q \in Q$ such that $(p,a,q) \in Q$.
\end{definition}
A run of $\calN$ on a word $\alpha \in A^\omega$ is an infinite sequence $\rho =
q_0 \alpha(1) q_1 \alpha(2) \dots \in (Q\cdot A)^\omega$ such that
$(q_i,\alpha(i+1),q_{i+1}) \in \Delta$ for all $i \in \mathbb{N}$. The automaton
is said to be \emph{deterministic} if for all $p \in Q$ and all $a \in A$ we
have that $(p,a,q_1), (p,a,q_2) \in \Delta$ implies $q_1 = q_2$.

Automata are equipped with a condition which determines which runs are
\emph{accepting}.  We put this extra information in the defining tuple of the
automaton (e.g., \(\calN = (Q, q_0, A, \Delta, U)\).  In this work we will
consider three conditions.
\begin{itemize}
  \item The \emph{safety} condition is defined with respect to a set $U
    \subseteq Q$ of \emph{unsafe states}. A run $\rho = q_0 a_1 q_1 a_2 \dots$
    is accepting for this condition, or safe, if and only if for all $i \in
    \mathbb{N}$ we have that $q_i \not\in U$.
  \item The \emph{B\"uchi} condition is defined with respect to a set of
    \emph{B\"uchi} or accepting states $B \subseteq Q$. A run $\rho = q_0
    a_1 q_1 a_2 \dots$ is accepting for this condition if and only if for
    all $i \in \mathbb{N}$ there exists $j \ge i$ such that $q_j \in B$.
    That is, the run visits accepting states infinitely often.  The parity
    condition can be implemented using a B端chi condition by doing some simple
    modifications on the underlying automaton.
    %% This is "needed" for the claim that every game is memoryless determined.
  \item The \emph{parity} condition is defined with respect to a
    \emph{priority function} $p\colon Q \to \mathbb{N}$. A run $\rho = q_0 a_1
    q_1 a_2 \dots$ is accepting for the parity condition if and only if the
    value $\liminf_{i \to \infty} p(q_i)$ is even.
\end{itemize}
A word $\alpha$ is accepted by the automaton $\calN$ if it has a run on $\alpha$
that is accepting.  The \emph{co-} variant of each model (e.g., co-B端chi
automaton) negates the condition, that is, it turns accepting runs into
rejecting ones, and vice versa.  The \emph{universal} variant
of each model (e.g., universal B端chi automaton) accepts a word if \emph{all} the
runs on the word are accepting.

We denote by $\lang{\calN}$ the \emph{language} of the automaton $\calN$, that
is, the set of words that $\calN$ accepts.

In this work we will see some states of our automata as ``bad'' and want to
ensure that no run on a given word visits them infinitely often.  Thus, the
variant we are most interested in is \emph{universal co-B端chi automata}, in
which a word is accepted if all its runs visit a prescribed set of states only
finitely often.

Finally, we note that deterministic parity automata generalize the other
conditions in the following sense:
\begin{proposition}[From~\cite{safra88,piterman07}]\label{prop:paritymr}
  For all (nondeterministic) B\"uchi automata $\calN$ there exists a
  deterministic parity automaton $\calD$ of exponential size with respect to the
  size of $\calN$ such that $\lang{\calN} = \lang{\calD}$.
\end{proposition}

\subsection{Synthesis games and strategies}
\begin{definition}[Games]
  A \emph{(Gale-Stewart) game} on input and output alphabets $I$ and $O$,
  respectively, is a two-player perfect-information game played by \eve and
  \adam in rounds: \adam chooses an element $i_k \in I$ and \eve responds with
  an element $o_k \in O$. A \emph{play} in such a game is an infinite word
  $\langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots \in (I\times O)^\omega$. 
\end{definition}
A game is paired with a \emph{payoff set} $P \subseteq (I \times
O)^\omega$ used to determine who wins a play $\pi$. If $\pi \in P$ then
\emph{$\pi$ is winning for \eve}, otherwise it is \emph{winning for \adam}.

\begin{definition}[Strategies]
  A \emph{strategy} for \adam in a game is a function $\tau\colon (I \times O)^*
  \to I$ which maps every (possibly empty) play prefix
  to a choice of input letter.  Similarly, a \emph{strategy for \eve}
  is a function $\sigma\colon (I \times O)^* I \to O$ which maps every play prefix
  and input letter to a choice of output letter.
\end{definition}
A play $\pi = \langle i_1, o_1\rangle \langle i_2, o_2\rangle \dots$ is
\emph{consistent with} a strategy $\tau$ for \adam if $i_k = \tau( \langle
i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle)$ for all $k \in
\mathbb{N}$; it is consistent with a strategy $\sigma$ for \eve if $o_k =
\sigma( \langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1}\rangle,
i_{k})$.  A pair of strategies $\sigma$ and $\tau$ for \eve and \adam,
respectively, induces a unique play $\out{\sigma}{\tau}$ consistent with both
$\sigma$ and $\tau$.

\paragraph*{Winning strategies.}
In a game with payoff set $P$, the strategy $\sigma$ for \eve is a \emph{winning
strategy} if for all strategies $\tau$ for \adam it holds that
$\out{\sigma}{\tau} \in P$; the strategy $\tau$ for \adam is winning if for all
strategies $\sigma$ for \eve we have $\out{\sigma}{\tau} \not\in P$.

\begin{proposition}[Borel determinacy~\cite{martin75}]
  For all games with Borel-definable payoff set $P$, it holds that there
  exists a winning strategy for \adam in the game if and only if there exists
  no winning strategy for \eve in the game.  Such games are said to be \emph{determined.}
\end{proposition}
We observe that all payoff sets induced by automata we consider in this work
are indeed Borel definable. It follows that all the games we will study are
determined.

\subsection{Realizability and synthesis}
The realizability and synthesis problems are defined for games whose payoff sets
are given as the language of an automaton. We sometimes refer to these as
\emph{games played on automata}.
\begin{definition}[Problems]
  Consider finite input and output alphabets $I$ and $O$, respectively, and
  an automaton $\calN$ with alphabet $I \times O$.
  The \emph{realizability problem} asks whether
  there exists a winning strategy for \eve in the game with payoff set 
  $\lang{\calN}$. The \emph{synthesis problem}
  further asks to compute and output such a strategy if one exists.
\end{definition}

\paragraph{Finite-memory strategies.}
A \emph{finite-memory} strategy $\sigma$ for \eve in a game played on the
automaton $\calN = (Q,q_0,I \times O,\Delta)$ with finite input and output
alphabets $I$ and $O$ is a strategy that can be encoded as a
\emph{(deterministic) Mealy machine}, that is, a finite-state machine that
outputs a letter from \(O\) when given a letter from \(I\).  Formally, such a
machine is a tuple $\calM = (S,s_0,I, \lambda_u,\lambda_o)$ where $S$ is a
finite set of (memory) states, $s_0$ is the initial state,
$\lambda_u\colon S \times (Q \times I) \to S$ is the update function and
$\lambda_o\colon S \times (Q \times I) \to O$ is the output function. The
machine encodes $\sigma$ in the following way. For all play prefixes
$\langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1} \rangle$ and input
letters $i_k \in I$ we have that
$\sigma(\langle i_1, o_1\rangle \dots \langle i_{k-1}, o_{k-1} \rangle, i_k) =
\lambda_o(s_k,i_k)$ where $s_{\ell + 1} = \lambda_u(s_\ell,i_\ell)$ for all
$\ell < k$. We then say the strategy $\sigma$ has \emph{memory} $|S|$. In
particular, when $|S| = 1$, we say the strategy is \emph{memoryless} (the term
\emph{positional} is also used in the literature).

\begin{proposition}[Memoryless determinacy for parity games~\cite{ag11}]
  \label{prop:det}%
  For all games played on deterministic parity automata, it holds that there
  exists a winning strategy for \eve in the game if and only if there exists a
  memoryless winning strategy for \eve.
\end{proposition}
Since the parity condition generalizes all the other conditions we consider in
this work, the above proposition implies memoryless determinacy for all our
games.  In particular, by \Cref{prop:paritymr}, games played on B端chi and safety
automata are also memoryless determined.

\section{Universal co-B\"uchi games}
In this section we present the Acacia~\cite{acacia} solution for the
realizability and synthesis problems for games played on (i.e. with payoff sets
expressed by) universal co-B\"uchi (UcB) automata.  Recall that these automata
deem a word accepted if no run on the word visits an accepting state infinitely
often.  We consider a stronger version of this acceptance condition which asks
that visits to accepting states be bounded by an explicit constant.

\begin{definition}[Universal \(K\)-co-B端chi automata]
  A universal $K$-co-B\"uchi (UKcB) automaton is a universal co-B端chi automaton
  $\calN = (Q,q_0,A,\Delta,B)$ with $B \subseteq Q$ the set of accepting
  states.  It accepts a word $\alpha$ if and only if all of its runs
  $\rho = q_0 \alpha(1) q_1 \alpha(2) \dots$ on $\alpha$ visit at most $K$
  accepting states, i.e. $|\{i \in \mathbb{N} : q_i \in B\}| < K$.
\end{definition}

Our intention is to give an incremental algorithm to solve games played on UcB
automata by solving the game played on the same automaton with UKcB semantics
for increasing values of $K$.  Note that a UcB automaton does not have to be
UKcB for any value of \(K\).  However, for any UcB automaton \(\calN\), there is
a value \(K\) for which the games played on \(\calN\) with UcB and UKcB semantics
are the same, in that they admit the same winning strategies.

Instead of working with UKcB automata directly, we will define equivalent
universal safety automata where counting up to \(K\) is embedded in the states.
As a starting point, with \(K = 1\), a UKcB is but a universal safety automaton:
as soon as a B\"uchi state is reached, the word should be
rejected. We extend this analogy for values
of \(K \geq 1\) by having this universal safety automaton count, up to \(K\), the
number of times accepting states are visited.  At the same time, we
\emph{determinize} this automaton using a powerset-like construction, and only
keep, for each state \(q\) of \(\calN\), the \emph{maximum} number of accepting
states visited upon reaching \(q\).  In practice, each state of our deterministic
safety automaton will be a function
\(f\colon Q \to \{0, \dots, K\} \cup \{\bot\}\); if a word reaches \(f\) with, say,
\(f(q) = i\), \(0 \leq i < K \), then the same word can reach \(q\) in
\(\calN\), never visiting more than \(i\) accepting states.
\begin{definition}[$K$-bounded deterministic safety automaton]
  For a given UcB automaton $\calN = (Q,q_0,A,\Delta,B)$ and $K \in \mathbb{N}$,
  let $\calS^K_\calN$ be the deterministic safety\mcnote{Correct?}
  automaton $(\calF,f_0,A,T,U)$ with components defined as follows.
  \begin{itemize}
    \item $\calF := \{f \colon Q \to \{0,\dots,K\} \cup
      \{\bot\}\}$, which is a finite set of functions,
    \item $f_0 \in \calF$ is such that $f_0(q_0) = 0$ and $f_0(q) =
      \bot$ for all $q \in Q$ such that $q \neq q_0$,
    \item $T$ consists of all triples $(f,a,g)$ such that for all $q \in Q$ we
      have
      \[
        g(q) = \max_{(p,a,q) \in \Delta}
        f(p) + \indicator{B}{q}
      \]
      where $\bot < n$ and $\bot + n = \bot$, for all $n \in \mathbb{N}$, and
      $K + 1 = K$.  If the \(\max\) is taken over an empty set, its value is \(\bot\).
    \item $U := \{ f \in \calF \mid f(q) = K \text{ for
      some } q \in Q \}$, the unsafe states.
  \end{itemize}
  The automaton $\calS^K_\calN$ accepts a word $\alpha$ if and only if its only
  run $f_0 \alpha(1) f_1 \alpha(2) \dots$ on $\alpha$ visits no state from $U$,
  i.e. $\forall i \in \mathbb{N} : f_i \not\in U$.
\end{definition}

The following property of $\calS^K_\calN$ follows from a straightforward
induction.
\begin{lemma}\label{lem:runs-visits}
  Let $\alpha \in A^\omega$ and $f_0 \alpha(1) f_1 \alpha(2) \dots$ be the
  unique run of $\calS^K_\calN$ on $\alpha$. For all $i \in \mathbb{N}$ and
  all $q \in Q$, if $f_i(q) \neq \bot$ then there exists a run $q_0
  \alpha(1) q_1 \alpha(2) \dots$ of $\calN$ on $\alpha$ such that $q_i = q$
  and $f_i(q) \leq |\{0 \leq j \leq i : q_j \in B\}|$.
\end{lemma}
The converse holds for large enough $K$ (see \Cref{lem:converse}).

\mcnote[inline]{I'm slightly confused by this lemma; you don't mean, in your
  ``there exists a run,'' that the \(q_j\)'s are the \(q_i\)'s you just ``defined''
  on the fly, right?  The statement would be \emph{less} confusing if the run in
  question weren't made explicit, in that case.  Also, why make \(q_i\) depend on
  \(i\)?  In other words, what about:\\ ``For all $i \in \mathbb{N}$ and all
  $q \in Q$ such that $f_i(q) \neq \bot$, there exists a run of $\calN$ on
  $\alpha$ which visits at least $f_i(q)$ accepting states.''\\Alternatively, if
  that's the intent:\\ ``For all $i \in \mathbb{N}$ there exists a run of $\calN$ on
  $\alpha$ which visits at least $\max_{q \in Q} f_i(q)$ accepting states.''\\  Or
  \emph{even more succinct}:\\ ``There exists a run of \(\calN\) on \(\alpha\) which
  visits at least \(\max_{i \in \mathbb{N}, q \in Q} f_i(q)\) accepting
  states.''}
%

The following is immediate from the lemma. 
\begin{corollary}\label{cor:safe-approx}
  For all $\alpha \in A^\omega$ and all $K,\ell \in \mathbb{N}$ with $\ell
  \leq K$, if there exists a run of $\calN$ on $\alpha$ which visits 
  at least $K$ accepting states then $\alpha \not\in \lang{\calS^\ell_\calN}$.
  In addition, the
  language of \(\calS^K_\calN\) is that of \(\calN\) with UKcB semantics,
  hence \(\lang{\calS^K_\calN} \subseteq \lang{\calN}\).
\end{corollary}

The second part of the above corollary allows us to argue that \eve winning
the game played on $\calS^K_\calN$ implies she wins the game played on
$\calN$.
\begin{lemma}
    Consider input and output alphabets $I$ and $O$, a UcB
    automaton $\calN$ with alphabet $I \times O$, a bound $K \in \mathbb{N}$,
    and the corresponding universal safety automaton $\calS^K_\calN$. A
    winning strategy for \eve in the game played on $\calS^K_\calN$
    is also a winning strategy for \eve in the game played on
    $\calN$.
\end{lemma}
\begin{proof}
  Consider a winning strategy \(\sigma\) for \eve in the game played on
  \(\calS^K_\calN\).  Any play \(\pi\) consistent with \(\sigma\) is such that
  \(\pi \in \lang{\calS^K_\calN}\), and by \Cref{cor:safe-approx},
  \(\pi \in \lang{\calN}\), showing that \(\sigma\) is a winning strategy for
  \eve in the game played on \(\calN\).\qed
\end{proof}

More interestingly, there exists a bound $K$ such that if \eve wins
the game played on $\calN$ then she also wins the one played on
$\calS^K_\calN$.  This relies on the memoryless determinacy of our games.
%
\begin{lemma}\label{lem:converse}
    Consider input and output alphabets $I$ and $O$ and a UcB automaton
    $\calN$ with alphabet $I \times O$. There exists a bound $K \in
    \mathbb{N}$, exponential with respect to the size of $\calN$, such that if
    there exists a winning strategy for \eve in the game played on $\calN$
    then there exists a winning strategy for \eve in the game played on
    $\calS^K_\calN$.
\end{lemma}
\begin{proof}[Sketch]
  Recall that every B\"uchi automaton can be ``determinized'' into a parity
  automaton of size at most exponential~\cite{safra88,piterman07}.
  Let us consider a deterministic parity\mcnote{I'd rather not talk about parity
    automata; we only use them for memoryless determinacy, and we already
    mention after \Cref{prop:det} that all our games have memoryless
    determinacy.} automaton $\calD$ such that $\lang{\calD} = \lang{\calN}$ and
  let $\sigma$ be the winning strategy for \eve in the game played on $\calN$ (and in
  the game played on $\calD$). By memoryless determinacy of parity games, there
  is a memoryless strategy $\mu$ for \eve in the game played on $\calD$. Since
  $\calD$ has exponential size with respect to the size of $\calN$,\mcnote{I
    don't see in \Cref{prop:det} or around a bound on the memory needed for the
    strategy, which seems to be what we need here.} there exists
  an exponential-memory strategy $\mu'$ for \eve in the game played on $\calN$. It
  follows that if any run of $\calN$ on a play $\pi$ consistent with $\mu'$ has
  visited sufficiently many accepting states, the Mealy machine realizing $\mu'$
  must have revisited some configuration. Hence, by ``pumping'' this behaviour,
  \adam must be able to win against $\mu'$, contradicting the fact that $\mu'$ is a
  winning strategy for \eve. We thus have an exponential upper bound on visits
  to accepting states for all runs on plays consistent with $\mu'$. By
  construction of $\calS^K_\calN$ we have that $\mu'$ is a winning strategy for
  \eve in the game played on $\calS^K_\calN$.  \qed
\end{proof}

\subsection{Some unsafe states are more unsafe than others}
There is a natural order on the states $f$ of $\calS^K_N$ induced by how many
times runs reaching each state $q$ with $f(q) \neq \bot$ have visited
accepting states. Formally, let us define the partial order $f \preceq g$
to hold if and only if for all $q \in Q$ we have $f(q) \leq g(q)$.

We say a state $q \in Q$ of a safety automaton $\calS$ is \emph{winning for \eve}
if she has a winning strategy from it --- that is, in the game played on
\(\calS\) where the initial state is set to \(q\). Otherwise, the
state is losing for her. It follows from Lemma~\ref{lem:runs-visits} that the set of
losing states from $\calS^K_\calN$ are \emph{$\preceq$-upwards closed}. We further
observe that $U$, the set of unsafe states of \(\calS^K_\calN\), is itself
$\preceq$-upwards closed.
\begin{proposition}\label{pro:up-closed}
  Let $f,g \in \mathcal{F}$ be states from $\calS^K_\calN$ such that $f
  \preceq g$.
  \begin{itemize}
    \item If $f \in U$ then $g \in U$.
    \item If $f$ is losing for \eve then $g$ is also losing for her.
  \end{itemize}
\end{proposition}

In the next section we recall the classical backwards algorithm for solving
safety and reachability games. We will give the algorithm directly for
$\calS^K_\calN$ and then state the necessary preliminaries for the symbolic
antichain-based algorithm to be presented.

\section{Solving safety games}
We refer to a game played on a deterministic safety automaton as a safety
game. Let us first consider safety games without making use of the partial order
on the states of \(\calS^K_\calN\).

\subsection{Explicit algorithm}
For this section, let $\calS = (Q,q_0, I \times O, \Delta, U)$ be a safety
game and let us write $\Delta(q,\langle i, o \rangle)$ for the unique state
$q' \in Q$ such that $(q, \langle i, o \rangle, q') \in \Delta$.

\paragraph{Uncontrollable predecessors.} The algorithm we describe
consists in iteratively applying a monotonically subset-increasing operator to
the set $U$ of unsafe states. The operator $\upre\colon \pow{Q} \to \pow{Q}$ is
defined for all $S \subseteq Q$ as follows.
\[
  \upre(S) := S \cup \{s \in Q \mid \exists i \in I, \forall o \in O : \Delta(s,\langle i, o \rangle) \in S\}
\]
Then, we inductively define $\upre^n(S)$ for all $n \in \mathbb{N}$ by setting
$\upre^0(S)$ to $S$ and $\upre^{n+1}(S)$ to $\upre(\upre^{n}(S))$.
The following is immediate from the definitions.
\begin{lemma}
  Let $S \subseteq Q$ and $n, m \in \mathbb{N}$ such that $n \leq m$. Then,
  $S \subseteq \upre^n(S) \subseteq \upre^m(S) \subseteq Q$.
\end{lemma}
Since $Q$ is finite, it follows that the $\upre^i(S)$ eventually stabilize
from some $i \leq |Q|$ onward.  Let us write $\upre^*(S)$ for said \emph{fixed point}
of $\upre$.

It is not hard to prove by induction that $\upre^*(U)$ coincides with the set
of states which are losing for \eve.
\begin{proposition}
  A state $q \in Q$ is losing for \eve if and only if $q \in \upre^*(U)$.
\end{proposition}

In the rest of this section we introduce a ``symbolic'' version of the $\upre$
operator which leverages the $\preceq$ ordering on states of $\calS^K_\calN$.

\subsection{Antichain-based algorithm}
We intend to leverage Proposition~\ref{pro:up-closed} to define an operator
which preserves upwards-closedness.
\gpnote[inline]{define the antichain-based algorithm}


\bibliographystyle{splncs04}
\bibliography{refs}

\end{document}

% LocalWords:  memoryless B端chi
